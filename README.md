# ModuCore Platform

**ModuCore Platform** 是一套 **「前端架構治理」為核心的工作平台導向（Work Platform Oriented）** 的系統實驗專案，  
專為「需要反覆產出同類型前端的中大型系統」的開發情境所設計。

平台以「模組」作為最小組裝單位，實踐低耦合、高可替換的架構原則，  
並透過高度結構化的世界模型，將模組、版型與設定統一納入平台治理，  
使專案能在既定規範下被快速組裝、裁決與重置。

ModuCore 的目標並非建立單一網站，而是打造一個  
**可承載多個專案世界（Project / World）** 的工作平台。  
在任何時間點，系統只存在於一個明確且可裁決的世界狀態中，  
並透過可預期的 boot 流程，降低重複開發成本，確保可擴展性與長期維護品質，  
適用於需要穩定複製並持續演化的企業級平台。

---

## 🎯 平台定位

ModuCore 是一個工作平台；  
Project 是世界實例；  
Module 是世界的構成實體；  
Container 是能力入口。

---

## 🧠 世界模型

所有平台設計皆以 **World Model** 為核心，  
世界模型定義了平台運行時的行為邊界、裁決規則與生命週期結構。

平台文件負責說明與實作對齊，  
實際規則裁決以世界模型所定義之主鏈為準。

---

## 🌍 世界（World）與專案（Project）

- 每一個 Project 對應一個世界實例（World Instance）
- 世界以 `tenant_id` 作為唯一識別
- 任一時間系統中僅允許存在單一世界
- 世界切換等同於現有世界的重置或替換

世界負責定義：

- 本世界允許啟用的模組集合
- 世界層級設定（config）
- 進入世界後的可用行為邊界

世界並非資料夾概念，而是平台在啟動後形成的  
**唯一有效且可工作的世界狀態**。

---

## 🔥 Container：世界能力的唯一入口

Container 容器模式作為平台中所有可被使用能力的集中入口，
模組無法直接互相依賴，必須透過 Container 取得所需功能，
以確保模組之間的低耦合與可替換性。其職責包含：

- 能力的註冊與存取
- 隔離模組之間的直接依賴
- 提供世界中所有可被使用的能力實體

Container **不負責**：

- 世界流程裁決
- 權限判斷
- 世界生命週期決策

世界的生命週期與行為邊界  
由平台與 lifecycle 規則主導，而非 Container 本身。

---

## 🧱 模組（Module）：世界的構成實體

模組是構成世界的功能實體，但其存在並非預設成立。

一個模組可以包含：

- UI（頁面 / 元件）
- Routes
- Store
- API 介面
- 權限語意（public / auth）
- Lifecycle（init / dispose）

### 模組存在判準

> **模組是否存在，以 `container.register` 為唯一判準。**

- 未被註冊的模組，視為不存在
- 模組可見性與權限裁決必須在註冊前完成
- 不可見或不合法的模組不得進入 Container

---

## 🧱 Store：狀態的權威來源

Store 負責世界中的狀態管理，  
且是影響世界未來行為的唯一權威來源。

### 狀態邊界原則

- 任何會影響世界未來行為的資料，必須進入 Store
- 不影響未來行為的資料，不得作為世界決策依據

### Store 的實作原則

為確保狀態具備單一權威性與可預期行為，
本平台的 Store 並非單純的資料容器，
而是建立於「容器註冊機制」與「可控的狀態響應策略」之上。

所有可影響世界未來行為的狀態，
必須透過容器註冊後由 Store 統一管理，
並以明確的存取與變更介面對外暴露，
避免狀態被隱性修改或在模組間流竄。

### Store 類型

#### 平台級 Store（Platform Stores）

- 世界層級狀態
- 由平台在 boot 階段建立與註冊
- 範例：
  - auth / token
  - platformConfig
  - lifecycle / session

#### 模組私有 Store（Module Stores）

- 僅服務模組內部狀態
- 隨模組註冊與移除進行建立或清理
- 不得被其他模組直接依賴

---

## 🚧 Routing：世界存取邊界

Routing Guard 作為使用者進入世界內容的最後防線，負責：

- 驗證使用者是否可進入當前世界狀態
- 阻擋未授權或不合法的存取行為

Routing 不作為：

- 模組存在判準
- 能力註冊依據
- 世界裁決核心

Routing 僅負責存取控制，不參與世界定義。

---

## 🔁 前端與後端關係

- 前端：負責世界模型實現、平台規則落實與能力組裝
- 後端：維持為薄後端，僅提供必要 API（登入、Session、基礎資料）

後端不參與世界裁決，  
僅作為世界運作所需的最小事實來源。

---

## 🧩 世界語意分層

```txt
┌──────────────────────────────┐
│           Platform           │ 世界規則 / lifecycle / guard
├──────────────────────────────┤
│        World (Project)       │ tenant_id / config
├──────────────────────────────┤
│           Container          │ 能力註冊與存取入口
├──────────────────────────────┤
│           Modules            │ UI / store / api
├──────────────────────────────┤
│        Backend (Thin)        │ auth / session / data
└──────────────────────────────┘
```

---

