這是一個所有功能都模組化的專案開發平台，平台的核心是一個container容器設計模式，他搜集所有的功能（能力）來組建這個世界。
整個世界得能力應該都是透過註冊到container來取得，保持低耦合才是模組化最大優勢。

我希望這個專案是同一個後端資料庫來根據前端不同專案入口來生成前端資料，這樣我就可以快速開發任何平台，而不用每次都開不同的資料表，（後端這塊只需要架構可通用的管理員跟會員，其他以後慢慢加，甚至這塊在最後才做也可以）

平台以vite＋vue3 來打包輸出專案，vue使用pug+sass編譯，（這個好像是最後面才要寫的，反正我想到就先寫了）

因為是專案開發平台，所以除了核心目錄應該還有一個平行目錄是專案目錄，裡面有著每個不同的專案目錄，專案目錄裡面會宣告自己是什麼專案，
還有模組目錄以及設定黨，讓設定黨可以依照設定讓vite來執行編譯build輸出專案內容。這樣我就可以將所有的專案使用同一套世界觀量產專案。

模組就像是ＵＳＢ一樣，依靠介面index.js搜集內部資料達到隨插即用的能力，(index.js就像usb的插口負責輸出輸入的介接口)。

router路由可能是唯一獨立出來的功能模組，因為他必須在世界生成的起點收集好業務模組是否在未登入時顯示以及何時該顯示哪裡該顯示，
所以他可能需要獨立於容器核心外，（但是這點我們可以還得思考，看看是否有辦法也將她收入容器），


樣式ＣＳＳ我希望可以做到一鍵替換，所以應該使用css的ＲＯＯＴ宣告樣式，我只要將底層標籤添加對應class就可以替換樣式，

登入前跟登入後身份，會有不同畫面介面，這裡就涉及到模組的index.js輸出能力的功能，

專案裡面的業務模組是生成世界畫面的主要來源，每個業務模組裡面都可以有（甚至應該是會）獨立的store,router,api,pages,assets,components，
只是用不用模組內可以自行決定，業務模組內可以自行import，但是模組外的東西只能使用容器呼叫，若是跨模組元件自己要import自己出去，
其他的都是用懶家載模式，在boot生成時判斷是否載入。



平台啟動的時候，設計一個生命週期流程，讓模組可以在對的時間載入，就能夠讓除錯有切斷錯誤點的能力，

平台會有自己的元件庫跟store還有api底層函式讓模組使用，

暫時想到這些，你可以開始問我了

//------------------------------



如果某個能力沒有被註冊進 container，
在你的世界裡，它是「不存在」還是「存在但不可被使用」？

他會是不存在，除非我們另外訂立特例，如同剛剛說的router，因為世界生成時是未登入，他應該只有平台功能，但是路由必須判斷業務模組是否有輸出頁面，
所以他可能會變成特例存在，但是如果我們慢慢完善世界，可能可以將它收入容器。




在你的世界裡，有沒有「任何情況」是
模組 必須知道 另一個模組存在的？

這一個問題我剛剛有一句 “若是跨模組元件自己要import自己出去”，所以他會在layout/目錄來組成所以Ａ跟Ｂ不太需要知道（跨模組問題可以因為api呼叫後端來實踐）
並不是一定要跨模組使用，因為不入庫的資料都是不重要的資料（這樣說會不會太絕對？）



「專案」這個概念，是前端的產物，
還是後端已經知道「有哪些世界正在存在」？

後端會使用資料隔離，應該會給他xxxx_id來判斷是誰的資料，而不是單獨開資料表。



如果刪掉某一個專案目錄，
這個世界發生的是「一個世界消失」，
還是「同一個世界少了一個出口」？

如果刪掉一個專案目錄，那就代表街口不見了，那就沒有這個模組，世界不會知道這個模組是否存在，所以我說是底耦合的模組世界


在你的世界裡，
模組是「插上就必定運作」，
還是「插上後，世界會決定是否啟用」？

插上去後需要設定是否顯示，顯示有兩種判斷，第一是是否讓未登入時顯示，第二是否在登入後顯示，如果兩個都不顯示就代表這個模組還沒準備好，
我在考慮需不需要再給一個管理員顯示，但是我覺得，這個可以在身份權限上做設定，所以必須再加一個路由守衛。



router 在你的世界裡，
是「描述世界長相的東西」，
還是「對世界做出裁決的東西」？

路由是決定帶領遊客去哪裡的功能，對世界而言，模組才是自己決定要不要顯示的，路由跟容器都是需要看模組的index.js是否輸出。且路由守衛是最後的防線。



使用者登入的那一刻，
世界發生的是「畫面變了」，
還是「整個世界被重建了一次」？

是畫面變了，但是需要做一個reset讓他能夠清空還原設定，這樣才不會被就資料感染



如果有一天你發現兩個模組
幾乎永遠一起被使用，
你比較傾向：

合併它們？
還是維持分離但建立一種「聯盟關係」？

合併他，或者將其一做為元件模組，元件模組就是沒有自己的頁面，但是又明確有業務能力，
低耦合是這個世界的理念，我希望所有東西都是可以拔除替換的，這樣升級更改都不會影響大世界的運行。


在平台啟動失敗時，
你最希望第一時間知道的是：

哪個模組壞了？
還是「世界卡在第幾個階段」？

會希望第一是卡在哪一個階段，才會想要知道是哪個模組出問題，雖然是模組世界，但是運行的生命週期才是除錯最重要的一環




//------------------------------




如果某模組的 index.js 存在、檔案也在、
只是忘了被註冊進 container，
在你的世界裡，這算是：
世界的一個錯誤？
還是世界對這個模組「視而不見」？

模組一定會有index.js這個檔案，因為他是介接口。沒有註冊進去容器代表模組目錄這一層的大index.js沒有收集到業務模組資料，
所以才會沒有註冊所以這一段應該會希望用vite去執行build前掃瞄各個模組資料出讓他自動化。
但是這不是世界的錯誤，而是世界本身就不必知道你的存在，世界只是在boot時，拿取目標專案的模組s /index.js根據這裡搜集的資料載入



在你的世界裡，
有沒有「重要，但不值得成為狀態」的東西？

如果有這樣的東西應該記錄在瀏覽器上，而不是入庫因此store必須設計能個判斷是否記錄在瀏覽器的工廠行生產函式，




在你的世界觀中，
xxxx_id 比較像是：

世界的身分證？
還是使用者暫時戴的面具？


世界不同國家的身分證，甚至說是不同平行時空的身分證。




當你說「世界不知道某個模組是否存在」，
你指的是：

世界 不關心
還是世界 不允許感知

世界不關心，就像地球她只管自己運行，但是他不會干涉上面的生物做什麼事情




一個「已插上、但不可見」的模組，
在你的世界裡：

它還會跑 init 嗎？
它會佔用 container 能力嗎？
它可以影響別人嗎？

他不會影響到任何模組，這裡還是要強調低耦合，他會被路由守衛擋在註冊進容器之前



在路由之前，
有沒有「更早的防線」存在？

世界生成時需要平台config來決定基礎顯示



reset 發生時，
世界是「回到剛啟動的狀態」，
還是「進入另一個既定狀態」？

應該是回到平台config載入後的狀態。大概是未登入前的狀態



元件模組在你的世界裡，
是「模組的一種」，
還是「模組的基礎材料」？

這個概念是對應到跨模組問題而生成的概念，因為不可否認肯定會有這樣的模組生成，只是多或少，我不可能將他當成平台元件所以定義成元件模組




每一個生命週期階段，
在你的世界裡，
是否「必須可以單獨重跑」？

並不是每一個都要能獨立重跑，但是需要一個切斷點讓除錯可以找到位置，
所以可能在boot的時候需要能夠有序的載入




//------------------------------



如果某個模組 偶爾存在、偶爾不存在
（例如某專案有、某專案沒有）
世界是否必須保證它的缺席是「安全的」？

在是強調低耦合的重要性，只要沒有耦合問題這就不是問題


世界是在 build-time 被決定，
還是在 run-time 才真正成立？

這個模組平台基本上是不使用run dev來開發，而是build之後從放到後端開放資料夾，然後從虛擬主機的網址看結果開發，
所以應該是build-time蒐集到資料決定



這些「重要但不入 store」的東西，
在世界裡比較像是：
環境條件（天氣）
暫時事件（雷聲）
還是世界記憶的一部分（歷史痕跡）？

暫時事件，歷史痕跡讓他記錄在瀏覽器就好，因為歷史如果造成痕跡了那就應該要影響世界而代表他必須入庫，如果他沒有到入庫的必要那就記錄在瀏覽器就可



在你的世界裡，
是否允許同一時間存在兩個不同 xxxx_id 的世界實例？

不同意，這是會有商業侵權的行為，必須杜絕（超級管理者）只能在資料庫或者是另外從後台特例!!觀看。



platformConfig 在你心中是：

世界誕生前的藍圖
還是世界誕生後的法律？

藍圖，他是會依照不同的國家世界生成不同的樣貌



container.register 發生的那一刻，
在你的世界裡算不算「模組已存在於世界中」？

要看路由守衛是否放行



reset 是：

世界倒帶
還是世界死亡後重生？

世界倒帶
恢復原廠設定




元件模組的生命，
是否永遠附屬於某個業務模組而存在？

不是，他會是模組就代表他有不可提帶性，如果他是一副某個業務模組存在，那他應該是在模組內的components



在你的世界裡，
是否存在一個 「一切錯誤都必須在此之前被發現」 的階段？

這個問題我不是很清楚，但是如果生命週期是可以攔截的，那應該是能清楚知道錯誤在哪裡，所以我不是很清楚你這個問題








//------------------------------






