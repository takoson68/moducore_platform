# API Error Model — World Semantic Errors

> 本文件定義 **「錯誤」在世界語意中的真正意義**。
>
> 此文件不描述錯誤格式、不描述傳輸狀態、不描述工程例外，
> 而是回答一個關鍵問題：
>
> 👉 **當 API 無法完成呼叫時，世界到底在對外表達什麼狀態？**

---

## 1. 世界中的「錯誤」不是失敗（Error ≠ Failure）

在工程語境中，「錯誤」常被理解為失敗或異常；
但在世界語意中，這種理解是錯誤的。

在本世界模型中：

> **錯誤不是系統失敗，而是世界對某個請求的語意回應。**

換言之：

* 世界沒有義務對所有請求給出結果
* 世界有權拒絕、忽略或隱藏狀態
* 世界的沉默，本身就是一種語意

---

## 2. 錯誤只可能出現在「世界已穩定」之後

基於 API_LIFECYCLE 的既定裁決：

* 世界未穩定 → API 不存在 → 無錯誤可言
* 世界已穩定 → API 合法存在 → 才有錯誤語意

因此：

> **任何在世界未穩定階段出現的 API 問題，都不是錯誤，而是非法呼叫。**

非法呼叫不屬於錯誤模型的一部分。

---

## 3. 世界層錯誤的四大語意分類

在世界語意中，API 的「錯誤」只可能屬於以下四類之一。

---

### 3.1 世界拒絕意圖（World Rejection）

**語意描述：**

> 世界已穩定，但拒絕接受該意圖。

可能原因包括：

* 意圖違反世界規則
* 意圖不符合當前世界身份
* 意圖在此世界階段不被允許

世界語意重點：

* 世界聽見了請求
* 世界明確選擇「不接受」

這不是錯誤，而是裁決結果。

---

### 3.2 世界狀態不可見（World Invisibility）

**語意描述：**

> 世界中存在某個狀態，但對當前視角不可見。

可能原因包括：

* 身份不足
* 世界隔離（跨世界殘影）
* 狀態被世界刻意隱藏

世界語意重點：

* 狀態可能存在
* 但世界選擇不揭露

---

### 3.3 世界尚未具備該狀態（World Absence）

**語意描述：**

> 世界已穩定，但該狀態尚未成立。

可能原因包括：

* 尚未被建立
* 尚未被任何世界行為生成

這不是錯誤，也不是失敗。

它只是：

> 世界目前沒有這個東西。

---

### 3.4 世界忽略該請求（World Ignorance）

**語意描述：**

> 世界聽見了請求，但選擇不回應。

可能原因包括：

* 請求來自不屬於此世界的身份
* 請求不具備任何世界意義

世界語意重點：

* 世界不需要解釋
* 世界不回應也是一種回應

---

## 4. 錯誤與 API 類型的關係

### 4.1 Query 與錯誤

Query 只可能遭遇：

* 世界狀態不可見（Invisibility）
* 世界尚未具備該狀態（Absence）
* 世界忽略該請求（Ignorance）

Query 不應遭遇：

* 世界拒絕意圖（那屬於 Command 語意）

---

### 4.2 Command 與錯誤

Command 只可能遭遇：

* 世界拒絕意圖（Rejection）
* 世界忽略該請求（Ignorance）

Command 永遠不保證任何結果成立。

---

## 5. 與工程錯誤的切割（Important Boundary）

以下情況 **不屬於世界錯誤模型**：

* 傳輸失敗
* 格式錯誤
* 語法錯誤
* 系統異常

這些都屬於工程層次，必須在世界語意之外被處理。

世界錯誤模型只描述：

> **世界是否、以及如何回應外部語意。**

---

## 6. 世界治理視角（Governance Perspective）

此錯誤模型的治理價值在於：

* 防止將世界拒絕誤當成系統失敗
* 防止工程層用補救機制掩蓋世界裁決
* 防止 AI Agent 誤以為 API 一定會回應

錯誤不是異常。

錯誤是世界。

---

## 7. 本文件的邊界（Document Boundary）

本文件：

* 不定義錯誤碼
* 不定義狀態格式
* 不涉及任何協定或技術名詞

本文件只完成一件事：

> **把錯誤從「系統問題」重新定義為「世界語意回應」。**

---

**API_ERROR_MODEL.md 至此結束，不延伸、不推論、不實作。**
